---
{"dg-publish":true,"permalink":"/CODING/C언어/어떤 방식으로 작동을 해야하는가/","noteIcon":"2"}
---



	제로부터 시작하는 코딩..

```
char *get_next_line(int fd)
{
	구조체 배열 milestone, 버퍼, 출력할 한줄, read의 반환값 저장할 함수 선언

	fd가 유효한 값으로 전달되었는지 확인
	출력할 한 줄을 널포인터로 초기화
	read의 반환값은 1로 초기화
		-> 처음 호출때만 실행되고 그 뒤로는 실행 안되게 해야됨
	
	while(read가 한 글자도 읽어오지 못할 때 까지 반복)
		변수에다 read가 몇글자 읽어왔는지 저장 (음수면 리턴해야됨)
		fd에 해당하는 구조체 포인터에 fill_back함수를 이용해 연결리스트의 주소 할당
		-> 이걸 파일 끝까지 반복
		-> 이 반복문이 끝나면 연결리스트의 콘텐츠에 파일 끝까지 들어가게됨
	
	while(리스트 끝까지 순회하면서)
		oneline으로 선언한 포인터에 조인 함수를 이용해 컨텐츠 내용을 기존 문자열 뒤에 넣어줌
		만약 해당 노드에 개행이 들어가있으면 반복문을 탈출함
	
	문자열이 합쳐진 oneline을 리턴
}

t_list *fill_back(t_list *lst, char *s)
{
	// 연결리스트를 이용해 노드의 컨텐츠에 버퍼사이즈 or 개행까지 문자를 잘라서 넣음
	우선 문자열의 첫글자가 널이면 새로운 노드를 만들어서 리턴한다.
	
	이후 check_null함수를 호출하는데 해당 함수에서 널 체크를 하고, 마지막 노드를 찾아서
	마지막노드 뒤에 last_node를 연결해준다.
	만약 check_null함수의 리턴값이 0으로 돌아온다면 malloc이 실패한 것이므로 free_node
	함수를 이용해 비어있는 노드 하나를 만들고 리턴한다.
	while (i < BUFFER_SIZE)
		그리고 버퍼사이즈만큼 반복을 하면서 각 node의 콘텐츠에 한 글자씩 집어넣는다.
		만약 해당 글자가 개행이라면 개행을 넣고 나서 is_nl 플래그를 1로 바꿔 준 뒤,
		마지막에 널을 찍어주고 재귀함수로 들어가 새로운 노드에 다음 문장을 넣어준다.
		또 만약 문자열이 끝이 났다면, 콘텐츠의 제일 뒤에 널을 찍고 반복문을 탈출한다
	
	마지막으로 연결리스트의 제일 첫 주소를 리턴하고 종료.
}
```

	milestone이 널인지 아닌지 체크를 해서 널일때만 read를 할 수 있도록 해야됨
	-> 버퍼 크기에 상관없이 반복문을 돌면서 파일 끝까지 무조건 읽어오기 떄문
	개행이 여러개 연달아서 들어올 때도 작동을 하지 않는다.
	read size가 0이어도 read 함수는 무조건 한번은 작동을 하는데, 이 반복문 안에 fillback함수가 있어서 비어있는 버퍼로 새로운 연결리스트를 만드는 바람에 뒤의 개행이 출력되지 않음

	read_size가 0일때 반복문을 탈출하게 하면 빈 파일이 들어왔을 때 segment fault가 남... 그렇다고 탈출안하게 하면 

- if (milestone[fd] == 0) 이런 조건을 줘야할듯..

- ft_strjoin에서 합치고 난 다음에 기존의 문자열 free가 필요할듯

구조체 배열 선언;
구조체 내용
문자열 하나 선언

매번 문자열에 join으로 뒤에 붙여서 파일 끝까지 읽기
리턴할 때는 개행까지 리턴한 다음 그 인덱스만큼 substr로 잘라버리기
s의 len이 0이되면 끝 (null)리턴하게