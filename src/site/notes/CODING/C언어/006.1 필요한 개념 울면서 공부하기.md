---
{"dg-publish":true,"permalink":"/CODING/C언어/006.1 필요한 개념 울면서 공부하기/","noteIcon":"2"}
---

### 우선은 PID
	pid란 Process identifier의 약자로, 프로세스마다 주어지는 번호같은거
	우리는 서로 다른 프로세스를 넘나들며 메세지를 보내고, 받은 다음에 답장 시그널을 보내야 하기 때문에 서로의 pid를 전달하고 받을 수 있어야 한다.

	getpid() 함수 쓰면 자기 pid 바로 리턴해줌 ㅋㅋㄹㅃㅃ
	그거 받아서 쓰면 된다고!!!

	리눅스는 3만 얼마까지 pid가 만들어진다고 한다.
	근데 계속 돌려보니 4만도 넘어감
	찾아보니 맥은 99999인가 99998까지 가능하다고 하네요~~~

### 다음은 KILL!!!!
	어떻게 함수 이름이 kill?
	무서운 이름과는 달리 그냥 인자로 전달받은 pid에 다음 인자로 전달받은 시그널을 쏴주는 녀석.
	이번 과제에서는 문자열을 비트로 바꿔 보내기 때문에 sigusr1, 2만 사용했지만, sigint나 다른 시그널을 보내주면 프로세스가 종료되기 때문에 kill이라는 무시무시한 이름이 붙은 것 같기도 하다.

### 쒸ㅣㅣㅣ뻘 개어려운 signal함수
	어느 10년 전의 블로그 글을 보고 무작정 따라 할 때는 쉬운 줄로만 알았다.
	사실 사용하기는 쉽긴 하다.
	그냥 특정 시그널이 들어오면 지정한 함수를 호출해주기로 미리 정해주는 함수다.
	하지만 무시무시한 점이 있었으니...

```c
void (*signal(int signum, void (*handler)(int)))(int);
```

	이게 함수 원형 꼬라지다........
	무슨 함수가 이렇게 생길 수가 있는지 모르겠다........
	해석을 좀 해보자면
	인자:
		int signum 시그널 번호
		void (*handler)(int) 시그널을 처리할 핸들러
	
	반환: void *()(int) 이전에 설정된 시그널 핸들러
	
	핸들러는 기본적으로 반환형이 없고 int 변수 하나를 받는 함수라고 생각하면 아주 조금 쉬워짐
	signal함수는 이전 핸들러를 반환해야 하니까
	void형이면서 int를 인자로 받는 함수의 포인터가 반환값이 되어야 한다.
	그래서 저런 몹쓸 모습이 되어버렸다.....라고 합니다.
	