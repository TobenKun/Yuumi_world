---
{"dg-publish":true,"permalink":"/CODING/C언어/005.4 제일 큰게 1이면 음수라니.../","noteIcon":"2"}
---

### MSD와 2의 보수라니
비트마스킹의 개념부터 알아보고 넘어가자.

내가 오늘 아침, 점심, 저녁을 각각 먹었는지 체크하기 위해서 비트 3개를 이용할 수 있다.
아침만 먹은 경우 : 100
점식 저녁을 먹은 경우 : 011
이렇게 사용할 수 있다.
저렇게 만든 숫자를 이용하면 0~7까지의 숫자로 내가 그날 끼니를 어떻게 먹었는지 알 수 있다.

비트마스킹은 숫자를 저렇게 true or false 로 나눠서 비트에 기록하는 것이다.

1~10 의 숫자 중에 1 3 5 7 9 가 있다면 -> 1010101010 이 되는 셈
(물론 실제로는 0부터 셀것이고 오른쪽부터 기록한다 보통)

이런 방식을 이용해서 나는 어떤 숫자들이 입력으로 들어왔는지 기록해두었다.

### 근데 저게 뭐가 문제냐고
흔히 컴퓨터는 0과 1로만 이루어져있다고 한다.
0과 1로만 있다는 말은 마이너스'-' 기호가 없다는 뜻이기도 하다...
그래서 컴퓨터는 0~128을
0 : 0000 0000
1 : 0000 0001
2 : 0000 0010
...
127 : 0111 1111
로 표현하고 -1~-128 을
-1 : 1111 1111
-2 : 1111 1110
...
-128 : 1000 0000 순으로 표현한다.

딱 보면 제일 큰 비트(MSB, Most Significant Bit)가 1일때 음수가 되는 것을 볼 수 있다.

근데 이거랑 내가 비트마스킹 한거랑 뭔상관이냐고?
기대하시라

### 의도치 않게 음수가 되네..
비어있는 비트가 0000 0000 이렇게 8개 있다고 치면,
내 프로그램은 특정 숫자를 받아와서 8로 나눈 나머지에 해당하는 인덱스의 비트를 1로 바꾼다.
10이 들어오면 비트는 0000 0100 이 된다.
(나머지는 2고 우측부터 나머지 0, 1, 2 기때문에 3번째 비트가 1이 된다)

만약 7이 들어온다면?
1000 0000이 되겠지? 근데 이거 아까 말했던것처럼 음수다.

잠깐 내 기존 코드를 보면,, 
```c
int	bit_count(int num)
{
	int	bit;

	bit = 0;
	while (num > 0)
	{
		num &= num - 1;
		bit++;
	}
	return (bit);
}
```
이런 모양인데 
어쩌다 MSB가 1이 되면 음수로 바뀌어서 반복문이 시작조차 되지 않는다.
대형 사고다 대형 사고.

### 내가 원하는 동작은
내가 원한건 MSB가 1이건 0이건 그냥 1인 비트가 몇개인지 세면 되는건데..

그래서.. 언제든 작동하게 뜯어고쳤다.
```c
int	bit_count(int num)
{
	int	bit;

	bit = 0;
	while (num > 0)
	{
		num &= num - 1;
		bit++;
	}
	if (num < 0)
	{ 
		num = ~num;
		while (num > 0)
		{
			num &= num - 1;
			bit++;
		}
		return (32 - bit);
	}
	return (bit);
}
```

처음으로 코드 짜면서 처음으로 ~연산을 써봤다. num이 음수면 not 연산으로 비트를 모조리 뒤집어버렸다.
그리고 똑같이 비트를 센 다음에 32에서 비트 숫자를 빼줬다.
1001 1100 이라는 비트가 들어오면
0110 0011 이라고 바꿔서 1비트가 몇개인지 센 다음에 8에서 빼주는 셈.

### 사실 나는 바보였다...
문제는 결국 제일 앞에 있는 비트가 1이 되면 (num > 0) 연산에 들어가지 않는 것이었다.
근데....

```c
int	bit_count(int num_tmp)
{
	int				bit;
	unsigned int	num;

	bit = 0;
	num = num_tmp;
	while (num != 0)
	{
		num &= num - 1;
		bit++;
	}
	return (bit);
}
```
	롸?

그냥 unsigned int로 바꿔버리면 되는거였음................................
unsigned int에는 음수가 없으니까....
그것이 부호없는 정수니까.. (끄덕)

오컴의 면도날 이야기가 진짜로 맞았던 건가보다.
이렇게 쉽고 간단할수가...