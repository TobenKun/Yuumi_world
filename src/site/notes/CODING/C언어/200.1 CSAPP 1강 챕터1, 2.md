---
{"dg-publish":true,"permalink":"/CODING/C언어/200.1 CSAPP 1강 챕터1, 2/","noteIcon":"2"}
---

1강에서 필요 없는 부분을 빼면 길지 않을 것 같아서 2챕터까지 합쳐봤다.
안되면 나누면 되니까

[[CODING/Study/CSAPP 1강 시스템과 비트의 세계\|CSAPP 1강 시스템과 비트의 세계]]
# Chapter 1 Tour of systems
### 추상화도 좋지만...
추상화는 분명 유용하다.
- 추상 자료형 (ICharater, IMateria ..)
- 점근적 분석 (BIg-O 표기법)

그럼에도 불구하고..
- 버그가 생겼을 때
- 내부 구현에 대한 이해가 필요할 때
어려움을 겪을 수 있다.

그러니 현실을 외면해서는 안된다.

### 현실1
정수형(int)은 정수형이 아니다.
실수형(float) 역시 실수가 아니다.

- $x^2 >= 0$
	- float: 항상 참
	- int: 오버플로가 나면 음수가 될 수 있음
- $(x + y) + z = x + (y + z)$
	- int & uint: 항상 참
	- float: $1e20 + (-1e20 + 3.14)$ --> ??

즉, 컴퓨터의 산술연산

- 결과값은 random하지 않다.
- 일반적인 수학적 성질들이 모두 성립한다고 가정할 수 없다

### 현실2
어셈블리는 알아야 한다.

어셈블리로 프로그램을 만들라는 이야기 X
어차피 컴파일러가 너보다 잘함

그래도 어셈블리를 이해하는건 중요하다.
- 버그가 났을때 프로그램 동작
- 프로그램 성능 향상
	- 컴파일러가 해주는/해주지 않는 최적화 이해
	- 프로그램이 느린 원인 이해

### 현실3
메모리는 중요하다.

메모리 성능은 균일하지 않다.
- 캐시와 가상 메모리는 프로그램의 성능에 지대한 영향을 미친다.
- 프로그램을 메모리 시스템의 특성에 맞게 하는 것이 속도 향상에 큰 도움이 된다.

메모리 참조 오류는 치명적이다.
- 논리적으로 전혀 상관 없는 대상이 오염될 수 있다.
- 버그가 생기고 한참 뒤에 발결될 가능성이 크다. (= 디버그 지옥)
- gc가 있는 언어를 쓸게 아니라면.. 공부해야지

### 현실4
Big-O 가 전부가 아니다
(점근적 복잡도 외에도 성능에 영향을 미치는 것이 있다.)

상수 계수도 중요하다.

정확한 연산 횟수도 성능을 예측해주는건 아니다.
- 코드를 어떻게 짜는가에 따라 10배의 차이가 날 수도 있다.
- 알고리즘, 데이터 표현, 함수구조, 반복문 등 여러 수준에서 최적화가 필요하다

최적화를 위해선 시스템을 반드시 이해해야 한다.
- 어떻게 프로그램이 컴파일되고 실행되는지
- 어떻게 프로그램의 성능을 측정하고 병목현상을 찾는지

copyij 함수와 copyji 함수의 실행 속도 차이 (이미지 첨부)
최적화 옵션을 사용하더라도 여전히 속도 차이가 남

### 현실5
컴퓨터가 프로그램 실행만 하는건 아니지

데이터가 오고 갈 수 있다.
- 입출력 시스템은 프로그램의 신뢰성과 성능에 매우 중요하다.

컴퓨터는 네트워크를 통해 서로 통신한다.
- 네트워크가 존재할 경우 많은 시스템 수준의 문제가 발생한다.
	- 자율적인 프로세스의 동시 실행으로 인한 문제
	- 신뢰할 수 없는 매체를 다루는 문제
	- 크로스 플랫폼 호환성 문제
	- 복잡한 성능 관련 문제

# Chapter2 비트, 바이트,  정수
### 모든 것은 비트다.
비트 모르는 사람 없죠?

근데 왜 비트를 쓰지?
- 전자적으로 구현하기 쉽다.
- 잡음이 많고 정확하지 않은 전선에서도 신뢰성 있게 전송할 수 있다.
- [읽어보면 좋은 글](https://puilin.tistory.com/28)

### 그 다음은 바이트
바이트도 다 알죠?

바이트 = 8비트
이진수: 00000000 - 11111111
십진수: 0 - 255
십육진수: 00 - FF

### 불 대수
조지 불 선생님이 만들었다.
참 값을 1, 거짓 값을 0으로 표현한다.

- And
- Or
- Not
- Xor

비트 벡터에서의 연산
- 각 비트별로 연산이 적용된다.

### 예시: 집합 표현/조작
n번째 비트의 값으로 요소n의 존재 여부 표현 가능
$a_j = 1$ if $j \in A$

연산
- & 교집합
- | 합집합
- ^ 대칭차(합집합 - 교집합)
- ~보수

### C에서의 비트 연산
C에서는 &, |, ~, ^ 연산을 사용할 수 있다.
- 모든 정수형 타입에 사용가능
	- long, int, short, char, unsigned
- 각 요소를 비트의 배열로 보고 각 비트별로 연산을 적용

### C에서의 논리 연산
&&, ||, ! 을 사용하여 논리 연산을 할 수 있따.
- 0은 거짓으로 여겨진다.
- 0이 아닌 모든 값은 참으로 여겨진다.
- 논리연산은 항상 0 또는 1을 반환한다.
- Early termination

예시
```
!0x41 -> 0x00
!0x00 -> 0x01
!!0x41 -> 0x01

0x69 && 0x55 -> 0x01
p && *p (널포인터 참조 방지)
```

논리연산이랑 비트연산을 바꿔 쓰는 경우는 없겠죠?

### 시프트 연산
좌측 시프트: x << y
- 비트 벡터 x를 왼쪽으로 y만큼 이동
- 왼쪽에서 넘어가는 비트는 버린다.
- 오른쪽은 0으로 채운다.

우측 시프트: x >> y
- x를 오른쪽으로 y만큼 이동
- 오른쪽에서 넘어가는 비트는 버린다.
- **논리 시프트와 산술 시프트로 구분된다**
- 논리 시프트
	- 왼쪽을 0으로 채운다.
- 산술 시프트
	- 가장 큰 비트와 같은 값으로 채운다.

정의되지 않은 행동
- 시프트 하는 값이 음수거나, 워드 사이즈보다 큰 경우


## 정수 표현: unsigned & signed

### 정수 인코딩
비트로 정수를 표현해보자

Unsigned 의 경우
$$ B2U(X) = \sum_{i=0}^{w-1}x_i * 2^i$$
Two's Complement (부호가 있는 경우)
$$ B2T(X) = -x_{w-1}*2^{w-1} + \sum_{i=0}^{w-2}x_i * 2^i$$

B2U -> binary to unsigned int
B2T -> binary to Two's Complement

식은 어렵게 보여도 안어렵다.
2의보수로 바꿀 때는 제일 큰 비트 값이 음수로 더해진다고 생각하면 됨


부호 비트
- 2의 보수에서 msb는 부호를 나타낸다.
	- 1이면 음수
	- 0이면 0 또는 양수

### 수의 범위
Unsigned
- UMin = 0 -> 000...0
- UMax = $2^w - 1$-> 111...1

Two's Complement
- TMin = $-2^{w-1}$ -> 100...0
- TMax = $2^{w-1} -1$ -> 011...1
- -1 -> 111...1

W = 16 일 때

|      | Decimal |   Hex |              Binary |
| ---- | ------: | ----: | ------------------: |
| UMax |   65535 | FF FF | `11111111 11111111` |
| TMax |   32767 | 7F FF | `01111111 11111111` |
| TMin |  -32768 | 80 00 | `10000000 00000000` |
| -1   |      -1 | FF FF | `11111111 11111111` |
| 0    |       0 | 00 00 | `00000000 00000000` |

- |TMin | = Tmax + 1
- UMax = 2 * TMax + 1

## 정수 변환
### Unsigned & Signed의 값
<표 첨부>

Equivalence
- 0과 양수의 인코딩(표현 방법)이 동일하다.

Uniqueness
- 모든 비트 패턴이 각각 다른 정수 값을 표현한다.
- 모든 표현 가능한 정수가 고유한 비트 표현 방식을 가진다.

-> Can Invert Mappings
- $U2B(x) = B2U^-1(x)$ unsigned값을 비트패턴으로 변환할 수 있다.
- $T2B(x) = B2T^-1(x)$ signed값(2의 보수)을 비트패턴으로 변환할 수 있다.

### 그러면 Signed값을 Unsigned로도?
쌉가능

2의 보수 -> unsigned
T2B -> B2U

unsigned -> 2의 보수
U2B -> B2T

쉽죠?

### Signed와 Unsigned의 관계
```
1011 0001 이런 비트 패턴이 있다고 하자.

1) unsigned로 해석할 경우
128 + 32 + 16 + 1 = 177

2) signed(2의 보수)로 해석할 경우
-128 + 32 + 16 + 1 = -79
```
예시에서 보듯이 가장 큰 비트가 음수 값을 가지고 있다고 *해석*한다.
하나의 비트 패턴을 두고 2가지 방법(signed, unsigned)로 해석이 가능함

### 변환의 시각화
2의보수 -> Unsigned
<그림 첨부>


### Signed vs Unsigned in C
상수 Constants
- 기본적으로 부호있는 정수
- 뒤에 U 붙으면 부호 없는 정수로 판단
	ex) 0U, 4242u

캐스팅
- signed와 unsigned간의 명시적 변환은 U2T, T2U와 같다.
```c
int tx, ty;
unsigned ux, uy;
tx = (int) ux;
uy = (unsigned) uy;
```

- 암시적인 형 변환은 변수에 값을 대입하거나 함수를 호출할 때에도 발생한다.


### 변환주의
<img src=https://cafe24.poxo.com/ec01/yunicm1/HOvhRhvOk+Cp2KY4JuusAhkeNo1Y+TlPEwUKdJ5CLv+bfUZMLJWrzIZy+s0mrRMdWhDrm9ehNJMz2ufdpkIPuQ==/_/web/product/big/202407/9af2d282e4e501d900e11576acc0453a.gif>

표현식 평가
- 한 표현식에 signed와 unsigned를 섞어쓰면 **signed 값이 unsigned로 암시적 변환 됨**
- `<, >, ==, <=, >=` 모두 포함

이렇게 생기는 함정
- -1은 0U 보다 크다...
- 2147483647 은 (int)2147483648U 보다 크다...

### 요약
Signed <-> Unsigned 변환 규칙
- 비트 패턴은 유지된다.
- 해석 방법이 다른 것 뿐
- 2^w 를 빼거나 더하는 경우가 생길 수 있다.
- 한 표현식에 같이 쓸 경우 암시적 변환이 일어난다.

## 정수 확장, 절삭
### 정수의 확장
int -> long의 형변환 같은 signed의 확장

부호 비트(MSB)를 필요한 길이 만큼 채운다.
1이면 1로, 0이면 0으로

unsigned의 확장
걍 0으로 채우십쇼

### 정수의 절삭
원하는 길이가 될 때 까지 앞쪽 비트를 지운다.

unsigned의 경우
나머지 연산을 한 것과 같음

signed의 경우
줄어든 비트 패턴을 2의 보수로 해석한다.
U2T(x mod 2^k)

### 요약
