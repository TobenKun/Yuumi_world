---
{"dg-publish":true,"permalink":"/CODING/C언어/005. 섞고 섞고 돌리고 섞고!/","noteIcon":"2"}
---

push_swap에 관하여

# 우선 숫자를 읽어오자
- 숫자가 잘 들어왔나 확인
- 숫자가 잘 들어왔으면 스택에 집어넣기
	- 집어넣기 전에 겹치는 숫자 있는지 확인하는게 좋을듯?
	- 체크함수 밖에 배열 만들어 놓고 포인터로 받아서 체크 -> 배열에 계속 저장되어있어야함
- 근데 "3 4 5"이렇게도 들어올 수 있어서 매번 split도 써줘야할듯??? 
[[CODING/C언어/005.1 단 한번의 탐색으로 중복 찾기\|005.1 단 한번의 탐색으로 중복 찾기]]

### 오늘의 실패
음수 양수 구분이 있었기 때문에 2진수로 기수정렬을 하려고 했으나,
내가 보기 너무 어려워서 중간에 포기...

몇번 정렬해야하는지도 딱 정할수가 없어서 포기하는게 맞는 것 같다.

걍 4진수로 야무지게 다시 짜야지
[[CODING/C언어/005.2 4진수 해보자고\|005.2 4진수 해보자고]]
### 나도 비트마스터!@
인덱싱을 하는 과정에서 비트를 탐색하면서 내가 몇번째 숫자인지 찾아주는 함수를 만들었다.
[[CODING/C언어/005.3 비트 마스터 신상현\|005.3 비트 마스터 신상현]]
아무리 생각해도 너무너무 기발한 방법이 아닐 수 없다.
근데 창의적인거 빼면 성능은 구림

배열을 전부 다 탐색해서 그런 것 같다.. 아직은 많이많이 느리다.

### 비트마스터 재취업.  
[[CODING/C언어/005.4 제일 큰게 1이면 음수라니...\|005.4 제일 큰게 1이면 음수라니...]]
잠깐 잊고 있었다... 컴퓨터는 제일 큰 비트가 1이되면 음수가 된다는 것을...

## 결국 해 내다.
4진수로 야무지게 짜기도 실패했다.
오히려 4진수는 스택 사이에서 왔다 갔다 하는데 명령어를 너무 많이 써서
조건을 도저히 만족할 수가 없었다.
코드를 아무리 닦고 조이고 기름쳤어도 100개 기준 1000개 안팍이 최대였을 듯

그래도 이겨내는 내가 이 시대의 진정한 히어로.
그리디로 해냈다.

[[CODING/C언어/005.5 greeeeeeedy\|005.5 greeeeeeedy]]

#### 그리고 실패...
int 최솟값까지는 잘 작동해야 하는데 atoi문제로 최솟값이 Error 처리가 되어버렸다...
```c
	while ('0' <= str[i] && str[i] <= '9')
	{
		result = result * 10 + (str[i++] - '0');
		if (result > 2147483647)
			print_error();
	}
```
아토이는 양수로 바꾼 다음에 마지막에 부호를 붙이는데
딱 저기 if 문에서 int 최솟값만 딱 걸린다...
```c
	while ('0' <= str[i] && str[i] <= '9')
	{
		result = result * 10 + (str[i++] - '0');
		if (result * sign > 2147483647 || result * sign < -2147483648)
			print_error();
	}
```
결국 이렇게 수정함 ㅋㅋ
아오 INT_MIN 시치

# 리트 하는 김에 최적화 조금 더
결국 no를 받기는 했는데, 평가 중에 좋은 스크립트를 알게 되어 테스트를 돌려보았다.
돌려 보니 최댓값이 750까지 튀는 경우도 가끔 있었음...
2000개를 돌리니까 하나 정도는 그럴 수 있다.

그치만 내 코드는 안돼

[[CODING/C언어/005.6 끝도 없이 늘어나는 하위문서...\|005.6 끝도 없이 늘어나는 하위문서...]]